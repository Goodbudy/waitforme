- movement logic
- goal queue management and timing managament
- create goal services, movement trigger services, 
- integrtion into my controller node, communication with path planning and localisation, 
- making launch files
- optimising and scaling for multupe turtlebots to pull from the same logic cpp file
- stte mchibe nd control flow


NOTES TO DO:
- table values (x/y) for service
- if anyone is idle, wait at certian pos (behind)
- launch file - remove gazebo stuff eventually - 
- localisation - identifier - figure out
- add namespace thing into my launch file for movementlogic and localisation
- change way services are accepted for different turtlebots



These cpp files exist in different packages, movementlogic.cpp exists in issy, and astar_planner exists in andy. Implement functions in movementlogic.cpp and astar_planner.cpp that will do the following:
1. movementlogic should publish goals received from the addgoals service one at a time to the atarplanner. 
2. astar_planner.cpp should subscribe to these goals and use them instead of hardcoded values to make the paths. 
3. astar_planner then sends these paths back to the movementlogic as path_publisher for it to subscribe to and use instead of nav2goal functionality to travel. ALL logic in both cpp files must be preserved.
So basically between each goal/destination, the astarplanner should be consulted for path planning. 

CODE FLOW EXAMPLE
- movementlogic action server moves turtlebot to home x/y position
- addgoals service publishes goal that movementlogic hears
- Movementlogic saves goal in queue
- addgoals service may publish other goals at anytime
- movement logic shall send the first goal to astarplanner
- astar planner used this goal to make a path
- astarplanner sends path back to movementlogic
- movementlogic waits for executegoals service and then used astarpath for travelling to goal
- turtlebot waits 5 seconds after reaching goal
- movementlogic sends home goal coordinates to astarplanner 
-astarplanner uses this goal to make path and sends path back to movementlogic
- movementlogic executes turtlebot movement following path back to homebase
- movementlogic sends next goal in queue to astarplanner
- repeat, maintaining all original code functionality such as waiting for services etc.

rewrite all of movementlogic.cpp and astarplanner.cpp implementing this new functionality. then provide step by step instructions on how to run it all.

#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <cmath>
#include <queue>
#include "issy/srv/add_goal.hpp"
#include "issy/srv/execute_goals.hpp"

using std::placeholders::_1;
using std::placeholders::_2;

class MovementLogic : public rclcpp::Node {
public:
    using NavigateToPose = nav2_msgs::action::NavigateToPose;
    using GoalHandleNav = rclcpp_action::ClientGoalHandle<NavigateToPose>;

    MovementLogic() : Node("movementlogic"), x_home(3.5), y_home(3.2), tolerance(0.2), executing_goal(false) {
        client_ = rclcpp_action::create_client<NavigateToPose>(this, "navigate_to_pose");

        // Wait for the action server to become available
        while (!client_->wait_for_action_server(std::chrono::seconds(1))) {
            RCLCPP_INFO(this->get_logger(), "Waiting for action server...");
        }

        // Subscribe to Odometry Data
        odom_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/odom", 10, std::bind(&MovementLogic::odom_callback, this, std::placeholders::_1));

        // Initiate movement to home base as soon as the node starts
        RCLCPP_INFO(this->get_logger(), "Navigating to home base...");
        navigate_to_home_base();

        // Start the services
        add_goal_service_ = this->create_service<issy::srv::AddGoal>(
            "add_goal", std::bind(&MovementLogic::handle_add_goal, this, _1, _2));

        execute_goals_service_ = this->create_service<issy::srv::ExecuteGoals>(
            "execute_goals", std::bind(&MovementLogic::handle_execute_goals, this, _1, _2));   
    }

private:
    rclcpp_action::Client<NavigateToPose>::SharedPtr client_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr odom_sub_;
    rclcpp::Service<issy::srv::AddGoal>::SharedPtr add_goal_service_;
    rclcpp::Service<issy::srv::ExecuteGoals>::SharedPtr execute_goals_service_;
    
    double x_home, y_home;
    double tolerance;
    double current_x = 0.0, current_y = 0.0;
    std::queue<std::pair<double, double>> goal_queue;
    bool executing_goal;
    bool home_base_reached = false;

    void handle_add_goal(const std::shared_ptr<issy::srv::AddGoal::Request> request,
        std::shared_ptr<issy::srv::AddGoal::Response> response) {
        goal_queue.push({request->x, request->y});
        response->success = true;
        response->message = "Goal added successfully.";
        RCLCPP_INFO(this->get_logger(), "Service: Added goal x=%.2f, y=%.2f", request->x, request->y);
    }

    void handle_execute_goals(const std::shared_ptr<issy::srv::ExecuteGoals::Request> /*request*/,
             std::shared_ptr<issy::srv::ExecuteGoals::Response> response) {
        if (!executing_goal && home_base_reached) {
            executing_goal = true;
            execute_next_goal();
            response->success = true;
            response->message = "Executing next goal.";
        } else {
            response->success = false;
            response->message = "Already executing or home base not yet reached.";
        }
    }

    void execute_next_goal() {
        if (!goal_queue.empty()) {
            auto [x_goal, y_goal] = goal_queue.front();
            goal_queue.pop();
            navigate_to(x_goal, y_goal, [this]() {
                RCLCPP_INFO(this->get_logger(), "Arrived at goal! Starting 5s countdown...");
                for (int i = 5; i > 0; --i) {
                    RCLCPP_INFO(this->get_logger(), "Waiting... %d seconds left", i);
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                }
                RCLCPP_INFO(this->get_logger(), "Countdown complete! Returning to home base...");
                navigate_to_home_base();
            });
        } else {
            RCLCPP_INFO(this->get_logger(), "No goals in the queue.");
            executing_goal = false;
        }
    }

    void navigate_to(double x, double y, std::function<void()> on_success) {
        auto goal_msg = NavigateToPose::Goal();
        goal_msg.pose.header.frame_id = "map";
        goal_msg.pose.header.stamp = this->now();
        goal_msg.pose.pose.position.x = x;
        goal_msg.pose.pose.position.y = y;
        goal_msg.pose.pose.orientation.w = 1.0;

        auto send_goal_options = rclcpp_action::Client<NavigateToPose>::SendGoalOptions();
        send_goal_options.result_callback = [this, on_success](const GoalHandleNav::WrappedResult & result) {
            if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
                RCLCPP_INFO(this->get_logger(), "Navigation successful!");
                on_success();
            }
        };

        client_->async_send_goal(goal_msg, send_goal_options);
    }

    void navigate_to_home_base() {
        navigate_to(x_home, y_home, [this]() {
            RCLCPP_INFO(this->get_logger(), "Returned to home base.");
            home_base_reached = true; // Mark home base as reached
            executing_goal = false;
            print_remaining_goals();
        });
    }

    void odom_callback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
        current_x = msg->pose.position.x;
        current_y = msg->pose.position.y;
    }

    void print_remaining_goals() {
        if (goal_queue.empty()) {
            RCLCPP_INFO(this->get_logger(), "Goal list is empty.");
        } else {
            RCLCPP_INFO(this->get_logger(), "Remaining goals:");
            std::queue<std::pair<double, double>> temp_queue = goal_queue;
            while (!temp_queue.empty()) {
                auto [x, y] = temp_queue.front();
                temp_queue.pop();
                RCLCPP_INFO(this->get_logger(), " - x=%.2f, y=%.2f", x, y);
            }
        }
    }
};

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MovementLogic>());
    rclcpp::shutdown();
    return 0;
}

#include "astar_planner.h"
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <cmath>
#include <nav_msgs/msg/occupancy_grid.hpp>
#include <opencv2/opencv.hpp>
#include <rclcpp/rclcpp.hpp>
#include "rclcpp_action/rclcpp_action.hpp"
#include "nav_msgs/msg/path.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"

AstarPlanner::AstarPlanner() : Node("astarplanner")
{
    occupancy_grid_sub_ = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
        "/map", 10, std::bind(&AstarPlanner::convertToBinaryGrid, this, std::placeholders::_1));
    RCLCPP_INFO(this->get_logger(), "Node Started");
    path_publisher_ = this->create_publisher<nav_msgs::msg::Path>("planned_path", 10);
}

// Each node represents a point on the grid.
// The cost is the distance travelled so far from the start
// The heuristic is a function define later that calcualtes the eclidean distance to the goal
// Parent points to the previous node
// the total cost is how far it has travelled and how far it is from the goal. I.E, low score is good

struct AstarPlanner::Point
{
    int x, y;
    float cost, heuristic;
    Point *parent;

    Point(int x, int y, float cost, float heuristic, Point *parent = nullptr)
        : x(x), y(y), cost(cost), heuristic(heuristic), parent(parent) {}

    float totalCost() const { return cost + heuristic; }
};

// This function is what is used to figure out what is the highest priority to search the next node.
// I.E if this node is a low cost, search from there first
struct AstarPlanner::ComparePoint
{
    bool operator()(const Point *a, const Point *b)
    {
        return a->totalCost() > b->totalCost();
    }
};

// Eclidiean distace from point to point
float AstarPlanner::eclidDist(int x1, int y1, int x2, int y2)
{
    return std::sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

void AstarPlanner::convertToBinaryGrid(const nav_msgs::msg::OccupancyGrid &map)
{
    double startX = 0;
    double startY = 0.5;
    double goalX = 0;
    double goalY = -2;
    int width = map.info.width;
    int height = map.info.height;
    origin_x = map.info.origin.position.x;
    origin_y = map.info.origin.position.y;
    resolution = map.info.resolution;
    RCLCPP_INFO(this->get_logger(), "origin x = %.2f, y = %.2f, resolution = %.2f", origin_x, origin_y, resolution);
    RCLCPP_INFO(this->get_logger(), "map data size = %zu", map.data.size());
    RCLCPP_INFO(this->get_logger(), "map width: %d map height: %d", width, height);
    if (map.data.size() != static_cast<size_t>(width) * height)
{
    RCLCPP_ERROR(this->get_logger(), "Map data size does not match width * height.");
    return;  // or handle this gracefully
}

    RCLCPP_INFO(this->get_logger(), "0");
    std::vector<std::vector<int>> binaryGrid(height, std::vector<int>(width, 0));
    RCLCPP_INFO(this->get_logger(), "1");
    //change this from 70 to width
    for (int x = 0; x < width; ++x)
    {
        // change this from 70 to height
        for (int y = 0; y < height; ++y)
        {   
            RCLCPP_INFO(this->get_logger(), "x pos: %d y pos: %d", x, y);
            int index = y * width + x;
            int value = map.data[index];

            // Mark as 1 if occupied or unknown
            if (value == 100 || value == -1)
            {
                binaryGrid[x][y] = 1;
                //RCLCPP_INFO(this->get_logger(), "ocupied");
            }
            else
            {
                binaryGrid[x][y] = 0;
                //RCLCPP_INFO(this->get_logger(), "freespace");
            }
        }
    }
    RCLCPP_INFO(this->get_logger(), "convert to binary");
    auto gridPath = AstarPlanner::aStarSearch(startX, startY, goalX, goalY, binaryGrid);
    std::vector<std::pair<double, double>> worldPath = convertGridToWorld(gridPath);
    AstarPlanner::saveGridAsImage(binaryGrid, "Binary Grid", gridPath);
    publishPath(worldPath);
}

// currently image is flipped in the x and y axis.
void AstarPlanner::saveGridAsImage(const std::vector<std::vector<int>> &grid, const std::string &filename, const std::vector<Point *> &path)
{
    RCLCPP_INFO(this->get_logger(), "image creating");
    int height = grid.size();
    int width = grid[0].size();

    // create an image in colour scale
    cv::Mat image(height, width, CV_8UC3);

    cv::circle(image, cv::Point(0, 0), 3, cv::Scalar(255, 255, 0), -1); // Cyan dot for origin

    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            if (grid[y][x])
            {
                // Obstacle (black)
                image.at<cv::Vec3b>(y, x) = cv::Vec3b(0, 0, 0); // Black for obstacles
            }
            else
            {
                // Free space (white)
                image.at<cv::Vec3b>(y, x) = cv::Vec3b(255, 255, 255); // White for free space
            }
        }
    }
    for (const auto &point : path)
    {
        RCLCPP_INFO(this->get_logger(), "Path point x: %d, Path point y: %d", point->x, point->y);
        image.at<cv::Vec3b>(point->y, point->x) = cv::Vec3b(0, 0, 255); // Red (BGR format)
    }

    RCLCPP_INFO(this->get_logger(), "image saved");
    std::string filePath = filename + ".png";
    cv::Mat rotated;
    cv::flip(image, rotated, -1); // Rotate 180°
    cv::imwrite(filePath, rotated);
}

std::vector<std::pair<double, double>> AstarPlanner::convertGridToWorld(std::vector<AstarPlanner::Point *> gridPath)
{
    std::vector<std::pair<double, double>> worldPath;
    for (const auto &path : gridPath)
    {
        double wx = path->x * resolution + origin_x + resolution / 2.0;
        double wy = path->y * resolution + origin_y + resolution / 2.0;
        worldPath.emplace_back(wx, wy);
        RCLCPP_INFO(this->get_logger(), "world path x: %.2f, y: %.2f", wx, wy);
    }
    return worldPath;
}

void AstarPlanner::publishPath(std::vector<std::pair<double, double>> worldPath)
{
    nav_msgs::msg::Path rosPath;
    rosPath.header.stamp = this->get_clock()->now();
    rosPath.header.frame_id = "map"; // Make sure it matches your TF

    for (const auto &[x, y] : worldPath)
    {
        geometry_msgs::msg::PoseStamped pose;
        pose.header.stamp = this->get_clock()->now();
        pose.header.frame_id = "map"; // Consistency with the path header

        pose.pose.position.x = x;
        pose.pose.position.y = y;
        pose.pose.position.z = 0.0;

        pose.pose.orientation.w = 1.0; // Neutral orientation

        rosPath.poses.push_back(pose);
    }

    // Publish the path
    path_publisher_->publish(rosPath);
    RCLCPP_INFO(this->get_logger(), "Published world path with %zu points", rosPath.poses.size());
}

// Impliment A* algorithim. Take an initial start X and Y positon, a goal X and Y Position and a map
// NOTE: x and y positions are relative to the Rviz map, internal conversion are done to change positions to grid locations
std::vector<AstarPlanner::Point *> AstarPlanner::aStarSearch(double startX, double startY, double goalX, double goalY, std::vector<std::vector<int>> &grid)
{
    std::priority_queue<Point *, std::vector<Point *>, ComparePoint> openList;
    std::unordered_map<int, Point *> visited;

    int gridStartX = (startX - origin_x) / resolution;
    int gridStartY = (startY - origin_y) / resolution;
    int gridGoalX = (goalX - origin_x) / resolution;
    int gridGoalY = (goalY - origin_y) / resolution;
    int width = grid[0].size(); // Needed for visited key calculation
    RCLCPP_INFO(this->get_logger(), "start x = %.2f, y = %.2f, grid start x = %d, y = %d ", startX, startY, gridStartX, gridStartY);
    RCLCPP_INFO(this->get_logger(), "goal x = %.2f, y = %.2f, grid goal x = %d, y = %d ", goalX, goalY, gridGoalX, gridGoalY);
    RCLCPP_INFO(this->get_logger(), "Map Resolution = %.2f", resolution);

    // Check start and goal validity
    if (grid[gridStartY][gridStartX] != 0 || grid[gridGoalY][gridGoalX] != 0)
    {
        RCLCPP_ERROR(this->get_logger(), "Start or Goal is in an obstacle");
        return {};
    }

    // Create an initial node at the start position with a cost of zero as it hasn't moved yet
    Point *start = new Point(gridStartX, gridStartY, 0, eclidDist(gridStartX, gridStartY, gridGoalX, gridGoalY));
    openList.push(start);

    // Define the movements allowed, I.E. up down left and right and diagonals.
    std::vector<std::pair<int, int>> directions = {
        {0, 1},   // up
        {1, 0},   // right
        {0, -1},  // down
        {-1, 0},  // left
        {1, 1},   // top-right
        {1, -1},  // bottom-right
        {-1, -1}, // bottom-left
        {-1, 1}   // top-left
    };

    // Start the A* loop, this will continue to run while there is nodes in the priority queue, as the initial node was pushed back above
    while (!openList.empty())
    {
        Point *current = openList.top();
        openList.pop();

        // Skip if already visited
        int currentKey = current->y * width + current->x;
        if (visited.count(currentKey))
            continue;

        visited[currentKey] = current;

        // check if we have reached the goal
        if (current->x == gridGoalX && current->y == gridGoalY)
        {

            // Reconstruct path
            std::vector<Point *> path;
            while (current)
            {
                RCLCPP_INFO(this->get_logger(), "New Node");
                path.push_back(current);
                current = current->parent;
            }
            return path;
        }
        // Generate Neighbour nodes
        for (auto [dx, dy] : directions)
        {
            int nx = current->x + dx;
            int ny = current->y + dy;
            // Check if the neighbour node is valid I.E within the bounds of the world and not an obstacle
            if (nx >= 0 && ny >= 0 && ny < static_cast<int>(grid.size()) && nx < static_cast<int>(grid[0].size()) && grid[ny][nx] == 0)
            {
                if (dx != 0 && dy != 0)
                {
                    if (grid[current->y][current->x + dx] != 0 || grid[current->y + dy][current->x] != 0)
                    {
                        continue; // Don't allow diagonal if either adjacent cardinal cell is an obstacle
                    }
                }
                int neighborKey = ny * width + nx;
                if (!visited.count(neighborKey))
                {
                    // cost to move, regualr left right up and down cost 1, diagonals as they are a further away cost 1.14
                    float moveCost = (dx == 0 || dy == 0) ? 1.0f : std::sqrt(2.0f);
                    float newCost = current->cost + moveCost;
                    Point *neighbor = new Point(nx, ny, newCost, eclidDist(nx, ny, gridGoalX, gridGoalY), current);
                    RCLCPP_ERROR(this->get_logger(), "Bad Node");
                    openList.push(neighbor);
                }
            }
        }
    }
    return {};
}

// Main function to test A*
int main(int argc, char *argv[])
{
    // std::vector<std::vector<int>> grid = {
    //     {0, 0, 0, 0, 1},
    //     {0, 1, 1, 0, 1},
    //     {0, 0, 0, 0, 0},
    //     {1, 1, 0, 1, 1},
    //     {0, 0, 0, 0, 0}
    // };

    // auto path = aStarSearch(0, 0, 4, 4, grid);

    // for (auto node : path) {
    //     std::cout << "(" << node->x << ", " << node->y << ") <- ";
    // }
    // std::cout << "Start\n";

    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<AstarPlanner>());
    rclcpp::shutdown();
    return 0;

    return 0;
}
















implement this:
- subscriber for goals
- check path publishing is good
- fix seg fault 
- increased functionality for continuous goals

me do 
- print out all statuses





































































fix the astar_planner.cpp file so that it communicates correctly with the movementlogic.cpp file. when I spin up both nodes in their separate packages they should interact with relevent subscribers and publishers. all logic in movementlogic should be preserved and its exact core functionality should be unchanged, but astar should not have any hardcoded functionality anymore.

ONCE BOTH NODES ARE SPUN UP THEY SHOULD DO THE FOLLOWING:
- movementlogic action server moves turtlebot to home x/y position
- addgoals service publishes goal that movementlogic hears
- Movementlogic saves goal in queue
- addgoals service may publish other goals at anytime
- movement logic shall send the first goal to astarplanner
- astar planner used this goal to make a path
- astarplanner sends path back to movementlogic
- movementlogic waits for executegoals service and then used astarpath for travelling to goal
- turtlebot waits 5 seconds after reaching goal
- movementlogic sends home goal coordinates to astarplanner 
-astarplanner uses this goal to make path and sends path back to movementlogic
- movementlogic executes turtlebot movement following path back to homebase
- movementlogic sends next goal in queue to astarplanner
- repeat, maintaining all original code functionality such as waiting for services etc.

rewrite the full code for movementlogic.cpp and astarplanner.cpp implementing ALL of the above functionality. then provide step by step instructions on how to run it all.

ASTAR_PLANNER.CPP

#include "astar_planner.h"
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <cmath>
#include <nav_msgs/msg/occupancy_grid.hpp>
#include <opencv2/opencv.hpp>
#include <rclcpp/rclcpp.hpp>
#include "rclcpp_action/rclcpp_action.hpp"
#include "nav_msgs/msg/path.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"

AstarPlanner::AstarPlanner() : Node("astarplanner")
{
    occupancy_grid_sub_ = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
        "/map", 10, std::bind(&AstarPlanner::convertToBinaryGrid, this, std::placeholders::_1));
    RCLCPP_INFO(this->get_logger(), "Node Started");
    path_publisher_ = this->create_publisher<nav_msgs::msg::Path>("planned_path", 10);
}

// Each node represents a point on the grid.
// The cost is the distance travelled so far from the start
// The heuristic is a function define later that calcualtes the eclidean distance to the goal
// Parent points to the previous node
// the total cost is how far it has travelled and how far it is from the goal. I.E, low score is good

struct AstarPlanner::Point
{
    int x, y;
    float cost, heuristic;
    Point *parent;

    Point(int x, int y, float cost, float heuristic, Point *parent = nullptr)
        : x(x), y(y), cost(cost), heuristic(heuristic), parent(parent) {}

    float totalCost() const { return cost + heuristic; }
};

// This function is what is used to figure out what is the highest priority to search the next node.
// I.E if this node is a low cost, search from there first
struct AstarPlanner::ComparePoint
{
    bool operator()(const Point *a, const Point *b)
    {
        return a->totalCost() > b->totalCost();
    }
};

// Eclidiean distace from point to point
float AstarPlanner::eclidDist(int x1, int y1, int x2, int y2)
{
    return std::sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

void AstarPlanner::convertToBinaryGrid(const nav_msgs::msg::OccupancyGrid &map)
{
    double startX = 0;
    double startY = 0.5;
    double goalX = 2.5;
    double goalY = 2.5;
    int width = map.info.width;
    int height = map.info.height;
    origin_x = map.info.origin.position.x;
    origin_y = map.info.origin.position.y;
    resolution = map.info.resolution;
    RCLCPP_INFO(this->get_logger(), "Map width: %d, Map height: %d", map.info.width, map.info.height);
    RCLCPP_INFO(this->get_logger(), "origin x = %.2f, y = %.2f, resolution = %.2f", origin_x, origin_y, resolution);
    RCLCPP_INFO(this->get_logger(), "map data size = %zu", map.data.size());
    RCLCPP_INFO(this->get_logger(), "map width: %d map height: %d", width, height);
    if (map.data.size() != static_cast<size_t>(width) * height)
{
    RCLCPP_ERROR(this->get_logger(), "Map data size does not match width * height.");
    return;  // or handle this gracefully
}


    RCLCPP_INFO(this->get_logger(), "0");
    std::vector<std::vector<int>> binaryGrid(height, std::vector<int>(width, 0));
    RCLCPP_INFO(this->get_logger(), "1");
    //change this from 70 to width
    for (int y = 0; y < height; ++y)
    {
        // change this from 70 to height
        for (int x = 0; x < width; ++x)
        {   
            RCLCPP_INFO(this->get_logger(), "x pos: %d y pos: %d", x, y);
            int index = y * width + x;
            int value = map.data[index];

            // Mark as 1 if occupied or unknown
            if (value == 100 || value == -1)
            {
                binaryGrid[y][x] = 1;
                //RCLCPP_INFO(this->get_logger(), "ocupied");
            }
            else
            {
                binaryGrid[y][x] = 0;
                //RCLCPP_INFO(this->get_logger(), "freespace");
            }
        }
    }
    RCLCPP_INFO(this->get_logger(), "convert to binary");
    auto gridPath = AstarPlanner::aStarSearch(startX, startY, goalX, goalY, binaryGrid);
    std::vector<std::pair<double, double>> worldPath = convertGridToWorld(gridPath);
    AstarPlanner::saveGridAsImage(binaryGrid, "Binary Grid", gridPath);
    publishPath(worldPath);
}

// currently image is flipped in the x and y axis.
void AstarPlanner::saveGridAsImage(const std::vector<std::vector<int>> &grid, const std::string &filename, const std::vector<Point *> &path)
{
    RCLCPP_INFO(this->get_logger(), "image creating");
    int height = grid.size();
    int width = grid[0].size();

    // create an image in colour scale
    cv::Mat image(height, width, CV_8UC3);

    cv::circle(image, cv::Point(0, 0), 3, cv::Scalar(255, 255, 0), -1); // Cyan dot for origin

    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            if (grid[y][x])
            {
                // Obstacle (black)
                image.at<cv::Vec3b>(y, x) = cv::Vec3b(0, 0, 0); // Black for obstacles
            }
            else
            {
                // Free space (white)
                image.at<cv::Vec3b>(y, x) = cv::Vec3b(255, 255, 255); // White for free space
            }
        }
    }
    for (const auto &point : path)
    {
        RCLCPP_INFO(this->get_logger(), "Path point x: %d, Path point y: %d", point->x, point->y);
        image.at<cv::Vec3b>(point->y, point->x) = cv::Vec3b(0, 0, 255); // Red (BGR format)
    }

    RCLCPP_INFO(this->get_logger(), "image saved");
    std::string filePath = filename + ".png";
    cv::Mat rotated;
    cv::flip(image, rotated, -1); // Rotate 180°
    cv::imwrite(filePath, rotated);
}

std::vector<std::pair<double, double>> AstarPlanner::convertGridToWorld(std::vector<AstarPlanner::Point *> gridPath)
{
    std::vector<std::pair<double, double>> worldPath;
    for (const auto &path : gridPath)
    {
        double wx = path->x * resolution + origin_x + resolution / 2.0;
        double wy = path->y * resolution + origin_y + resolution / 2.0;
        worldPath.emplace_back(wx, wy);
        RCLCPP_INFO(this->get_logger(), "world path x: %.2f, y: %.2f", wx, wy);
    }
    return worldPath;
}

void AstarPlanner::publishPath(std::vector<std::pair<double, double>> worldPath)
{
    nav_msgs::msg::Path rosPath;
    rosPath.header.stamp = this->get_clock()->now();
    rosPath.header.frame_id = "map"; // Make sure it matches your TF

    for (const auto &[x, y] : worldPath)
    {
        geometry_msgs::msg::PoseStamped pose;
        pose.header.stamp = this->get_clock()->now();
        pose.header.frame_id = "map"; // Consistency with the path header

        pose.pose.position.x = x;
        pose.pose.position.y = y;
        pose.pose.position.z = 0.0;

        pose.pose.orientation.w = 1.0; // Neutral orientation

        rosPath.poses.push_back(pose);
    }

    // Publish the path
    path_publisher_->publish(rosPath);
    RCLCPP_INFO(this->get_logger(), "Published world path with %zu points", rosPath.poses.size());
}

// Impliment A* algorithim. Take an initial start X and Y positon, a goal X and Y Position and a map
// NOTE: x and y positions are relative to the Rviz map, internal conversion are done to change positions to grid locations
std::vector<AstarPlanner::Point *> AstarPlanner::aStarSearch(double startX, double startY, double goalX, double goalY, std::vector<std::vector<int>> &grid)
{
    std::priority_queue<Point *, std::vector<Point *>, ComparePoint> openList;
    std::unordered_map<int, Point *> visited;

    int gridStartX = (startX - origin_x) / resolution;
    int gridStartY = (startY - origin_y) / resolution;
    int gridGoalX = (goalX - origin_x) / resolution;
    int gridGoalY = (goalY - origin_y) / resolution;
    int width = grid[0].size(); // Needed for visited key calculation
    RCLCPP_INFO(this->get_logger(), "start x = %.2f, y = %.2f, grid start x = %d, y = %d ", startX, startY, gridStartX, gridStartY);
    RCLCPP_INFO(this->get_logger(), "goal x = %.2f, y = %.2f, grid goal x = %d, y = %d ", goalX, goalY, gridGoalX, gridGoalY);
    RCLCPP_INFO(this->get_logger(), "Map Resolution = %.2f", resolution);

    // Check start and goal validity
    if (grid[gridStartY][gridStartX] != 0 || grid[gridGoalY][gridGoalX] != 0)
    {
        RCLCPP_ERROR(this->get_logger(), "Start or Goal is in an obstacle");
        return {};
    }

    // Create an initial node at the start position with a cost of zero as it hasn't moved yet
    Point *start = new Point(gridStartX, gridStartY, 0, eclidDist(gridStartX, gridStartY, gridGoalX, gridGoalY));
    openList.push(start);

    // Define the movements allowed, I.E. up down left and right and diagonals.
    std::vector<std::pair<int, int>> directions = {
        {0, 1},   // up
        {1, 0},   // right
        {0, -1},  // down
        {-1, 0},  // left
        {1, 1},   // top-right
        {1, -1},  // bottom-right
        {-1, -1}, // bottom-left
        {-1, 1}   // top-left
    };

    // Start the A* loop, this will continue to run while there is nodes in the priority queue, as the initial node was pushed back above
    while (!openList.empty())
    {
        Point *current = openList.top();
        openList.pop();

        // Skip if already visited
        int currentKey = current->y * width + current->x;
        if (visited.count(currentKey))
            continue;

        visited[currentKey] = current;

        // check if we have reached the goal
        if (current->x == gridGoalX && current->y == gridGoalY)
        {

            // Reconstruct path
            std::vector<Point *> path;
            while (current)
            {
                //RCLCPP_INFO(this->get_logger(), "New Node");
                path.push_back(current);
                current = current->parent;
            }
            return path;
        }
        // Generate Neighbour nodes
        for (auto [dx, dy] : directions)
        {
            int nx = current->x + dx;
            int ny = current->y + dy;
            // Check if the neighbour node is valid I.E within the bounds of the world and not an obstacle
            if (nx >= 0 && ny >= 0 && ny < static_cast<int>(grid.size()) && nx < static_cast<int>(grid[0].size()) && grid[ny][nx] == 0)
            {
                if (dx != 0 && dy != 0)
                {
                    if (grid[current->y][current->x + dx] != 0 || grid[current->y + dy][current->x] != 0)
                    {
                        continue; // Don't allow diagonal if either adjacent cardinal cell is an obstacle
                    }
                }
                int neighborKey = ny * width + nx;
                if (!visited.count(neighborKey))
                {
                    // cost to move, regualr left right up and down cost 1, diagonals as they are a further away cost 1.14
                    float moveCost = (dx == 0 || dy == 0) ? 1.0f : std::sqrt(2.0f);
                    float newCost = current->cost + moveCost;
                    Point *neighbor = new Point(nx, ny, newCost, eclidDist(nx, ny, gridGoalX, gridGoalY), current);
                    //RCLCPP_ERROR(this->get_logger(), "Bad Node");
                    openList.push(neighbor);
                }
            }
        }
    }
    return {};
}

// Main function to test A*
int main(int argc, char *argv[])
{
    // std::vector<std::vector<int>> grid = {
    //     {0, 0, 0, 0, 1},
    //     {0, 1, 1, 0, 1},
    //     {0, 0, 0, 0, 0},
    //     {1, 1, 0, 1, 1},
    //     {0, 0, 0, 0, 0}
    // };

    // auto path = aStarSearch(0, 0, 4, 4, grid);

    // for (auto node : path) {
    //     std::cout << "(" << node->x << ", " << node->y << ") <- ";
    // }
    // std::cout << "Start\n";

    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<AstarPlanner>());
    rclcpp::shutdown();
    return 0;

    return 0;
}

MOVEMENTLOGIC.CPP

#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav2_msgs/action/navigate_to_pose.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <cmath>
#include <queue>
#include "issy/srv/add_goal.hpp"
#include "issy/srv/execute_goals.hpp"
#include "nav_msgs/msg/path.hpp"
#include "geometry_msgs/msg/twist.hpp"

using std::placeholders::_1;
using std::placeholders::_2;

class MovementLogic : public rclcpp::Node {
public:
    using NavigateToPose = nav2_msgs::action::NavigateToPose;
    using GoalHandleNav = rclcpp_action::ClientGoalHandle<NavigateToPose>;

    MovementLogic() : Node("movementlogic"), x_home(3.5), y_home(3.2), tolerance(0.2), executing_goal(false) {
        client_ = rclcpp_action::create_client<NavigateToPose>(this, "navigate_to_pose");

        // Wait for the action server to become available
        while (!client_->wait_for_action_server(std::chrono::seconds(1))) {
            RCLCPP_INFO(this->get_logger(), "Waiting for action server...");
        }

        // Subscribe to Odometry Data
        odom_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/odom", 10, std::bind(&MovementLogic::odom_callback, this, std::placeholders::_1));

        // Subscribe to the path topic
        path_sub_ = this->create_subscription<nav_msgs::msg::Path>(
            "/planned_path", 10, std::bind(&MovementLogic::path_callback, this, _1));

        // Publish velocity commands
        cmd_vel_pub_ = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel", 10);

        goal_publisher_ = this->create_publisher<geometry_msgs::msg::PoseStamped>("/astar_goal", 10);

        // Initiate movement to home base as soon as the node starts
        RCLCPP_INFO(this->get_logger(), "Navigating to home base...");
        navigate_to_home_base();

        // Start the services
        add_goal_service_ = this->create_service<issy::srv::AddGoal>(
            "add_goal", std::bind(&MovementLogic::handle_add_goal, this, _1, _2));

        execute_goals_service_ = this->create_service<issy::srv::ExecuteGoals>(
            "execute_goals", std::bind(&MovementLogic::handle_execute_goals, this, _1, _2));   
        
        // Timer to execute path-following
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(100),
            std::bind(&MovementLogic::follow_path, this));
    }

private:
    rclcpp_action::Client<NavigateToPose>::SharedPtr client_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr odom_sub_;
    rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr path_sub_;
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_pub_;
    rclcpp::Service<issy::srv::AddGoal>::SharedPtr add_goal_service_;
    rclcpp::Service<issy::srv::ExecuteGoals>::SharedPtr execute_goals_service_;
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr goal_publisher_;

    double x_home, y_home;
    double tolerance;
    double current_x = 0.0, current_y = 0.0;
    std::queue<std::pair<double, double>> goal_queue;
    std::vector<geometry_msgs::msg::PoseStamped> current_path_;
    size_t current_target_index_ = 0;
    bool executing_goal;
    bool home_base_reached = false;
    bool following_path_ = false;

    void handle_add_goal(const std::shared_ptr<issy::srv::AddGoal::Request> request,
        std::shared_ptr<issy::srv::AddGoal::Response> response) {
        goal_queue.push({request->x, request->y});
        response->success = true;
        response->message = "Goal added successfully.";
        RCLCPP_INFO(this->get_logger(), "Service: Added goal x=%.2f, y=%.2f", request->x, request->y);
    }

    void handle_execute_goals(const std::shared_ptr<issy::srv::ExecuteGoals::Request> /*request*/,
             std::shared_ptr<issy::srv::ExecuteGoals::Response> response) {
        if (!executing_goal && home_base_reached) {
            executing_goal = true;
            execute_next_goal();
            response->success = true;
            response->message = "Executing next goal.";
        } else {
            response->success = false;
            response->message = "Already executing or home base not yet reached.";
        }
    }

    // void execute_next_goal() {
    //     if (!goal_queue.empty()) {
    //         auto [x_goal, y_goal] = goal_queue.front();
    //         goal_queue.pop();
    //         navigate_to(x_goal, y_goal, [this]() {
    //             RCLCPP_INFO(this->get_logger(), "Arrived at goal! Starting 5s countdown...");
    //             for (int i = 5; i > 0; --i) {
    //                 RCLCPP_INFO(this->get_logger(), "Waiting... %d seconds left", i);
    //                 std::this_thread::sleep_for(std::chrono::seconds(1));
    //             }
    //             RCLCPP_INFO(this->get_logger(), "Countdown complete! Returning to home base...");
    //             navigate_to_home_base();
    //         });
    //     } else {
    //         RCLCPP_INFO(this->get_logger(), "No goals in the queue.");
    //         executing_goal = false;
    //     }
    // }

    void execute_next_goal() {
        if (!goal_queue.empty()) {
            auto [x_goal, y_goal] = goal_queue.front();
            goal_queue.pop();
    
            publish_goal_to_astar(x_goal, y_goal);
    
            RCLCPP_INFO(this->get_logger(), "Published goal to astar planner: x=%.2f, y=%.2f", x_goal, y_goal);
        } else {
            RCLCPP_INFO(this->get_logger(), "No goals in the queue.");
            executing_goal = false;
        }
    }    

    void publish_goal_to_astar(double x, double y) {
        geometry_msgs::msg::PoseStamped goal_msg;
        goal_msg.header.frame_id = "map";
        goal_msg.header.stamp = this->now();
        goal_msg.pose.position.x = x;
        goal_msg.pose.position.y = y;
        goal_msg.pose.orientation.w = 1.0;
    
        goal_publisher_->publish(goal_msg);
    }    

    void navigate_to(double x, double y, std::function<void()> on_success) {
        auto goal_msg = NavigateToPose::Goal();
        goal_msg.pose.header.frame_id = "map";
        goal_msg.pose.header.stamp = this->now();
        goal_msg.pose.pose.position.x = x;
        goal_msg.pose.pose.position.y = y;
        goal_msg.pose.pose.orientation.w = 1.0;

        auto send_goal_options = rclcpp_action::Client<NavigateToPose>::SendGoalOptions();
        send_goal_options.result_callback = [this, on_success](const GoalHandleNav::WrappedResult & result) {
            if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
                RCLCPP_INFO(this->get_logger(), "Navigation successful!");
                on_success();
            }
        };

        client_->async_send_goal(goal_msg, send_goal_options);
    }

    void navigate_to_home_base() {
        navigate_to(x_home, y_home, [this]() {
            RCLCPP_INFO(this->get_logger(), "Returned to home base.");
            home_base_reached = true; // Mark home base as reached
            executing_goal = false;
            print_remaining_goals();
        });
    }

    void odom_callback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
        current_x = msg->pose.position.x;
        current_y = msg->pose.position.y;
    }

    void path_callback(const nav_msgs::msg::Path::SharedPtr msg) {
        if (msg->poses.empty()) return;
        current_path_ = msg->poses;
        current_target_index_ = 0;
        following_path_ = true;
        RCLCPP_INFO(this->get_logger(), "Received new path with %zu poses", current_path_.size());
    }

    void follow_path() {
        if (!following_path_ || current_target_index_ >= current_path_.size()) return;

        auto target_pose = current_path_[current_target_index_].pose;
        double dx = target_pose.position.x - current_x;
        double dy = target_pose.position.y - current_y;
        double distance = std::sqrt(dx * dx + dy * dy);

        if (distance < 0.2) {
            current_target_index_++;
            if (current_target_index_ >= current_path_.size()) {
                RCLCPP_INFO(this->get_logger(), "Reached final path goal.");
                following_path_ = false;
            }
            return;
        }

        // Simple proportional control
        geometry_msgs::msg::Twist cmd_vel;
        cmd_vel.linear.x = 0.5 * distance;
        cmd_vel.angular.z = 1.0 * std::atan2(dy, dx);
        cmd_vel_pub_->publish(cmd_vel);
    }

    void print_remaining_goals() {
        if (goal_queue.empty()) {
            RCLCPP_INFO(this->get_logger(), "Goal list is empty.");
        } else {
            RCLCPP_INFO(this->get_logger(), "Remaining goals:");
            std::queue<std::pair<double, double>> temp_queue = goal_queue;
            while (!temp_queue.empty()) {
                auto [x, y] = temp_queue.front();
                temp_queue.pop();
                RCLCPP_INFO(this->get_logger(), " - x=%.2f, y=%.2f", x, y);
            }
        }
    }
};

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MovementLogic>());
    rclcpp::shutdown();
    return 0;
}



// #include "rclcpp/rclcpp.hpp"
// #include "geometry_msgs/msg/pose_stamped.hpp"
// #include "nav2_msgs/action/navigate_to_pose.hpp"
// #include "rclcpp_action/rclcpp_action.hpp"
// #include <iostream>
// #include <string>
// #include <thread>
// #include <chrono>
// #include <cmath>
// #include <queue>
// #include "issy/srv/add_goal.hpp"
// #include "issy/srv/execute_goals.hpp"

// using std::placeholders::_1;
// using std::placeholders::_2;

// class MovementLogic : public rclcpp::Node {
// public:
//     using NavigateToPose = nav2_msgs::action::NavigateToPose;
//     using GoalHandleNav = rclcpp_action::ClientGoalHandle<NavigateToPose>;

//     MovementLogic() : Node("movementlogic"), x_home(3.5), y_home(3.2), tolerance(0.2), executing_goal(false) {
//         client_ = rclcpp_action::create_client<NavigateToPose>(this, "navigate_to_pose");

//         // Wait for the action server to become available
//         while (!client_->wait_for_action_server(std::chrono::seconds(1))) {
//             RCLCPP_INFO(this->get_logger(), "Waiting for action server...");
//         }

//         // Subscribe to Odometry Data
//         odom_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
//             "/odom", 10, std::bind(&MovementLogic::odom_callback, this, std::placeholders::_1));

//         // Initiate movement to home base as soon as the node starts
//         RCLCPP_INFO(this->get_logger(), "Navigating to home base...");
//         navigate_to_home_base();

//         // Start the services
//         add_goal_service_ = this->create_service<issy::srv::AddGoal>(
//             "add_goal", std::bind(&MovementLogic::handle_add_goal, this, _1, _2));

//         execute_goals_service_ = this->create_service<issy::srv::ExecuteGoals>(
//             "execute_goals", std::bind(&MovementLogic::handle_execute_goals, this, _1, _2));   

//     }

// private:
//     rclcpp_action::Client<NavigateToPose>::SharedPtr client_;
//     rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr odom_sub_;
//     rclcpp::Service<issy::srv::AddGoal>::SharedPtr add_goal_service_;
//     rclcpp::Service<issy::srv::ExecuteGoals>::SharedPtr execute_goals_service_;
    
//     double x_home, y_home;
//     double tolerance;
//     double current_x = 0.0, current_y = 0.0;
//     std::queue<std::pair<double, double>> goal_queue;
//     bool executing_goal;
//     bool home_base_reached = false;

//     void handle_add_goal(const std::shared_ptr<issy::srv::AddGoal::Request> request,
//         std::shared_ptr<issy::srv::AddGoal::Response> response) {
//         goal_queue.push({request->x, request->y});
//         response->success = true;
//         response->message = "Goal added successfully.";
//         RCLCPP_INFO(this->get_logger(), "Service: Added goal x=%.2f, y=%.2f", request->x, request->y);
//     }

//     void handle_execute_goals(const std::shared_ptr<issy::srv::ExecuteGoals::Request> /*request*/,
//              std::shared_ptr<issy::srv::ExecuteGoals::Response> response) {
//         if (!executing_goal && home_base_reached) {
//             executing_goal = true;
//             execute_next_goal();
//             response->success = true;
//             response->message = "Executing next goal.";
//         } else {
//             response->success = false;
//             response->message = "Already executing or home base not yet reached.";
//         }
//     }

//     void execute_next_goal() {
//         if (!goal_queue.empty()) {
//             auto [x_goal, y_goal] = goal_queue.front();
//             goal_queue.pop();
//             navigate_to(x_goal, y_goal, [this]() {
//                 RCLCPP_INFO(this->get_logger(), "Arrived at goal! Starting 5s countdown...");
//                 for (int i = 5; i > 0; --i) {
//                     RCLCPP_INFO(this->get_logger(), "Waiting... %d seconds left", i);
//                     std::this_thread::sleep_for(std::chrono::seconds(1));
//                 }
//                 RCLCPP_INFO(this->get_logger(), "Countdown complete! Returning to home base...");
//                 navigate_to_home_base();
//             });
//         } else {
//             RCLCPP_INFO(this->get_logger(), "No goals in the queue.");
//             executing_goal = false;
//         }
//     }

//     void navigate_to(double x, double y, std::function<void()> on_success) {
//         auto goal_msg = NavigateToPose::Goal();
//         goal_msg.pose.header.frame_id = "map";
//         goal_msg.pose.header.stamp = this->now();
//         goal_msg.pose.pose.position.x = x;
//         goal_msg.pose.pose.position.y = y;
//         goal_msg.pose.pose.orientation.w = 1.0;

//         auto send_goal_options = rclcpp_action::Client<NavigateToPose>::SendGoalOptions();
//         send_goal_options.result_callback = [this, on_success](const GoalHandleNav::WrappedResult & result) {
//             if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
//                 RCLCPP_INFO(this->get_logger(), "Navigation successful!");
//                 on_success();
//             }
//         };

//         client_->async_send_goal(goal_msg, send_goal_options);
//     }

//     void navigate_to_home_base() {
//         navigate_to(x_home, y_home, [this]() {
//             RCLCPP_INFO(this->get_logger(), "Returned to home base.");
//             home_base_reached = true; // Mark home base as reached
//             executing_goal = false;
//             print_remaining_goals();
//         });
//     }

//     void odom_callback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
//         current_x = msg->pose.position.x;
//         current_y = msg->pose.position.y;
//     }

//     void print_remaining_goals() {
//         if (goal_queue.empty()) {
//             RCLCPP_INFO(this->get_logger(), "Goal list is empty.");
//         } else {
//             RCLCPP_INFO(this->get_logger(), "Remaining goals:");
//             std::queue<std::pair<double, double>> temp_queue = goal_queue;
//             while (!temp_queue.empty()) {
//                 auto [x, y] = temp_queue.front();
//                 temp_queue.pop();
//                 RCLCPP_INFO(this->get_logger(), " - x=%.2f, y=%.2f", x, y);
//             }
//         }
//     }
// };

// int main(int argc, char **argv) {
//     rclcpp::init(argc, argv);
//     rclcpp::spin(std::make_shared<MovementLogic>());
//     rclcpp::shutdown();
//     return 0;
// }
